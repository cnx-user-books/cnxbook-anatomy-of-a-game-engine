<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Slick0150: A first look at sprite motion, collision detection, and timing control</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m45738</md:content-id>
  <md:title>Slick0150: A first look at sprite motion, collision detection, and timing control</md:title>
  <md:abstract>Learn to make sprites move at a constant speed in front of an image in the face of a widely varying frame rate. Also learn about a rudimentary form of collision detection.</md:abstract>
  <md:uuid>c92f070e-494f-4eb1-a0b9-e36abe4359fd</md:uuid>
</metadata>

<content>
















<section id="h11000">
<title>
Table of Contents

</title>




<list id="ul1000" list-type="bulleted">

	

<item id="li1000">
<link id="a1000" target-id="Preface">

Preface

</link>


	

<list id="ul1001" list-type="bulleted">

		

<item id="li1001">
<link id="a1001" target-id="Viewing_tip">

Viewing tip

</link>


<list id="ul1002" list-type="bulleted">

			

<item id="li1002">
<link id="a1002" target-id="Figures">

Figures

</link>


</item>


			

<item id="li1003">
<link id="a1003" target-id="Listings">

Listings

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>


	

<item id="li1004">
<link id="a1004" target-id="Preview">

Preview

</link>

 

</item>


	

<item id="li1005">
<link id="a1005" target-id="General_background_information">

General background information

</link>


</item>


	

<item id="li1006">
<link id="a1006" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>


<list id="ul1003" list-type="bulleted">

		

<item id="li1007">

		

<link id="a1007" target-id="A_program_with_a_relatively_constant_frame_rate_Slick0150a">

A 
		program with 
		a relatively constant frame rate - Slick0150a

</link>


<list id="ul1004" list-type="bulleted">

			

<item id="li1008">
<link id="a1008" target-id="The_screen_output_for_Slick0150a">

The screen output 
			for Slick0150a

</link>


</item>


			

<item id="li1009">
<link id="a1009" target-id="Beginning_of_the_class_named_Slick0150a">

Beginning of the class named Slick0150a

</link>


</item>


			

<item id="li1010">
<link id="a1010" target-id="The_constructor_and_the_main_method">

The constructor 
			and the main method

</link>


</item>


			

<item id="li1011">
<link id="a1011" target-id="The_init_method">

The init method

</link>


</item>


			

<item id="li1012">
<link id="a1012" target-id="The_update_method">

The update method

</link>


</item>


			

<item id="li1013">
<link id="a1013" target-id="The_render_method">

The render method

</link>


</item>


		

</list>


		

</item>


		

<item id="li1014">
<link id="a1014" target-id="A_program_with_a_highly_variable_frame_rate_Slick0150b">

A 
		program with a 
		highly variable frame rate Slick0150b

</link>


<list id="ul1005" list-type="bulleted">

			

<item id="li1015">
<link id="a1015" target-id="The_screen_output_for_Slick0150b">

The screen output 
			for Slick0150b

</link>


</item>


			

<item id="li1016">
<link id="a1016" target-id="The_render_method_2">

The render method

</link>


</item>


			

<item id="li1017">
<link id="a1017" target-id="The_update_method_2">

The update method

</link>


</item>


		

</list>


		

</item>


	

</list>


	

</item>


	

<item id="li1018">
<link id="a1018" target-id="Run_the_program">

Run the programs

</link>


</item>


	

<item id="li1019">
<link id="a1019" target-id="Summary">

Summary

</link>

 

</item>


	

<item id="li1020">
<link id="a1020" target-id="Whats_next">

What's next?

</link>


</item>


	

<item id="li1021">
<link id="a1021" target-id="Miscellaneous">

Miscellaneous

</link>


</item>


	

<item id="li1022">
<link id="a1022" target-id="Complete_program_listing">

Complete program listings

</link>


</item>




</list>


	

	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	

	

<para id="p1000">
This module is one in a collection of modules designed to teach you about 
	the anatomy of a game engine.

</para>




<para id="p1001">
Although the modules in this collection will concentrate on the Java game 
library named Slick2D, the 
concepts involved and the knowledge that you will gain is applicable to 
different game engines written in different programming languages as well.

</para>




<para id="p1002">
The purpose of this module is teach you how to make sprites move at a constant speed in front of an image in the face of a widely varying 
frame rate. You will also learn about a rudimentary form of collision detection.

</para>


	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1003">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
	and Listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>


	

<list id="ul1006" list-type="bulleted">

		

<item id="li1023">
<link id="a1023" target-id="Figure_1">

Figure 1

</link>

. Image of a ladybug. 

</item>


		

<item id="li1024">
<link id="a1024" target-id="Figure_2">

Figure 2

</link>

. Background image. 

</item>


		

<item id="li1025">
<link id="a1025" target-id="Figure_3">

Figure 3

</link>

. Screen shot of the program named Slick0150a. 

</item>


		

<item id="li1026">
<link id="a1026" target-id="Figure_4">

Figure 4

</link>

. Screen shot of the program named Slick0150b. 

</item>


		

<item id="li1027">
<link id="a1027" target-id="Figure_5">

Figure 5

</link>

. Screen shot of the program named Slick0150b without correction for varying frame rate.

</item>



	

</list>


	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1007" list-type="bulleted">

		

<item id="li1028">
<link id="a1028" target-id="Listing_1">

Listing 1

</link>

. Beginning of the class named Slick0150a.

</item>


		

<item id="li1029">
<link id="a1029" target-id="Listing_2">

Listing 2

</link>

. The init method for Slick0150a. 

</item>


		

<item id="li1030">
<link id="a1030" target-id="Listing_3">

Listing 3

</link>

. Beginning of the update method 
		for Slick0150a. 

</item>


		

<item id="li1031">
<link id="a1031" target-id="Listing_4">

Listing 4

</link>

. Detection of collision with right edge. 

</item>


		

<item id="li1032">
<link id="a1032" target-id="Listing_5">

Listing 5

</link>

. Test for collisions on other three sides of game window.

</item>


		

<item id="li1033">
<link id="a1033" target-id="Listing_6">

Listing 6

</link>

. The render method for Slick150a.

</item>


		

<item id="li1034">
<link id="a1034" target-id="Listing_7">

Listing 7

</link>

. The render method for Slick150b.

</item>


		

<item id="li1035">
<link id="a1035" target-id="Listing_8">

Listing 8

</link>

. Beginning of the update method for Slick0150b.

</item>


		

<item id="li1036">
<link id="a1036" target-id="Listing_9">

Listing 9

</link>

. Source code for the program named Slick0150a.

</item>


		

<item id="li1037">
<link id="a1037" target-id="Listing_10">

Listing 10

</link>

. Source code for the program named Slick0150b.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>




<para id="p1004">
<emphasis id="strong1000" effect="bold">
What you have learned

</emphasis>
</para>




<para id="p1005">
In the previous module, you learned that while there are many classes and 
interfaces in the Slick2D library with names that match the names of classes and 
interfaces in the standard edition Java library, they are not the 
same.

</para>




<para id="p1006">
You learned that you can access the Slick2D documentation at 


<link id="a1038" url="http://slick.ninjacave.com/javadoc/">


http://slick.ninjacave.com/javadoc/

</link>

. 

<emphasis id="em1000" effect="italics">
(A copy of the documentation is 
also included in the distribution zip file.)

</emphasis>
</para>




<para id="p1007">
You learned how to set the drawing mode so that bitmap images drawn in the 
game window will either honor or not honor transparent pixels.

</para>




<para id="p1008">
You learned how to draw bitmap images in the game window using both the


<emphasis id="strong1001" effect="bold">
draw

</emphasis>
 methods of the 

<emphasis id="strong1002" effect="bold">
Image

</emphasis>
 class and the


<emphasis id="strong1003" effect="bold">
drawImage

</emphasis>
 methods of the 

<emphasis id="strong1004" effect="bold">
Graphics

</emphasis>
  class.

</para>




<para id="p1009">
<emphasis id="strong1005" effect="bold">
What you will learn

</emphasis>
</para>




<para id="p1010">
In this module, you will learn how to make sprites move at a constant speed in front of an image in the face of widely varying 
frame rates. You will also learn about a rudimentary form of collision detection.

</para>


	

</section>
<section id="h11003">
<title>
<emphasis id="General_background_information" effect="bold">

General 
	background information

</emphasis>


</title>




<para id="p1011">
<emphasis id="strong1006" effect="bold">
The update and render methods

</emphasis>
</para>




<para id="p1012">
Following initialization, the Slick2D game engine switches back and forth 
between an 

<emphasis id="strong1007" effect="bold">
update

</emphasis>
 method and a 

<emphasis id="strong1008" effect="bold">
render

</emphasis>
 method.

</para>




<para id="p1013">
We write code to control the state of the game in the 

<emphasis id="strong1009" effect="bold">
update

</emphasis>
 
method. We write code to display the state of the game in the 

<emphasis id="strong1010" effect="bold">
render

</emphasis>
 
method.

</para>




<para id="p1014">
<emphasis id="strong1011" effect="bold">
A sprite

</emphasis>
</para>




<para id="p1015">
According to one definition, a sprite is 

<emphasis id="em1001" effect="italics">
a computer graphic that may be moved on-screen and otherwise manipulated as a single entity.

</emphasis>
</para>




<para id="p1016">
We will use the image of the ladybug shown in 

<link id="a1039" target-id="Figure_1">

Figure 1

</link>

 
as a sprite in two different programs that I will explain in this module.

</para>







<table id="table1000" summary="This is a table." pgwide="1">
<tgroup cols="1">




<thead id="thead1000">



<row id="tr1000">



<entry id="th1000">



<emphasis id="Figure_1" effect="bold">

Figure 1

</emphasis>

. Image of a ladybug.


</entry>



</row>



</thead>




<tbody id="tbody1000">



<row id="tr1001">



<entry id="td1000">



<media id="media1000" alt="Missing image." display="block">
<image id="img1000" mime-type="image/jpeg" src="../../media/slick0150a1.jpg" width="154" height="179"/>
</media>




</entry>



</row>



</tbody>




</tgroup>
</table>






<para id="p1017">
We will cause that sprite to move in front of the background image shown in


<link id="a1040" target-id="Figure_2">

Figure 2

</link>

.

</para>






<table id="table1001" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1001">
<row id="tr1002">
<entry id="th1001">



<emphasis id="Figure_2" effect="bold">

Figure 2

</emphasis>

. Background image.


</entry>
</row>
</thead>


<tbody id="tbody1001">
<row id="tr1003">
<entry id="td1001">



<media id="media1001" alt="Missing image." display="block">
<image id="img1001" mime-type="image/jpeg" src="../../media/slick0150a2.jpg" width="414" height="307"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>






<para id="p1018">
<emphasis id="strong1012" effect="bold">
A bouncing sprite

</emphasis>
</para>




<para id="p1019">
In particular, we will cause the sprite to bounce around inside the game 
window like a pool ball on a pool table. Whenever it strikes an edge of the game 
window, it will bounce off in the opposite direction. This process will continue 
until the program is terminated.

</para>




<para id="p1020">
<emphasis id="strong1013" effect="bold">
The target frame rate

</emphasis>
</para>




<para id="p1021">
As you learned in an earlier module, a 

<emphasis id="strong1014" effect="bold">
GameContainer

</emphasis>
 method named


<emphasis id="strong1015" effect="bold">
setTargetFrameRate

</emphasis>
 can be called in an attempt to cause the 
program to run at a constant frame rate.

</para>




<para id="p1022">
This method can slow the frame rate down to the target value on fast 
computers. However, it cannot speed the frame rate up to the target value on 
slower computers.

</para>




<para id="p1023">
Therefore, a call to the 

<emphasis id="strong1016" effect="bold">
setTargetFrameRate

</emphasis>
 method should 
actually be viewed as setting the maximum frame rate that the program will run.

</para>




<para id="p1024">
<emphasis id="strong1017" effect="bold">
An appearance of achieving the target frame rate

</emphasis>
</para>




<para id="p1025">
Sometimes it is important to cause the program to give the appearance of 
running at the target frame rate even if it is actually running slower. 

</para>




<para id="p1026">
One example is when a sprite is moving across the game window. It is often 
desirable to cause the sprite to move at the same overall speed regardless of 
the speed of the computer. For example, you probably wouldn't want a missile to 
take a long time to reach its target on a slow computer and a short time to 
reach its target on a fast computer.

</para>




<para id="p1027">
<emphasis id="strong1018" effect="bold">
Accuracy versus graphic quality

</emphasis>
</para>




<para id="p1028">
I will explain a program in this module that is designed to achieve such a 
result. The upside is that you can often achieve the appearance of the target 
frame rate in terms of the overall speed of the sprite. The downside is that the 
motion of the sprite may be less smooth than would be the case if the computer 
were actually running at the target frame rate.

</para>




<para id="p1029">
<emphasis id="strong1019" effect="bold">
The parameter named delta

</emphasis>
</para>




<para id="p1030">
Each time the

<emphasis id="strong1020" effect="bold">
 update

</emphasis>
 method is called, it receives an 
incoming parameter named delta whose value is the number of milliseconds that 
have elapsed since the most recent call to the 

<emphasis id="strong1021" effect="bold">
update

</emphasis>
 method. 
In the case of a highly varying frame rate, such as may occur when the 

<emphasis id="strong1022" effect="bold">

render

</emphasis>
 method is required to draw a complex and constantly changing 
scene, the value of delta may vary significantly from one call to the next of 
the

<emphasis id="strong1023" effect="bold">
 update

</emphasis>
 method. 

</para>




<para id="p1031">
Fortunately, the value of delta can often be used to give the appearance of 
running at the target frame rate even though the actual frame rate may be below 
the target. I will show you how to do that in this module.

</para>


	

	

</section>
<section id="h11004">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	

	

<section id="h21001">
<title>
<emphasis id="A_program_with_a_relatively_constant_frame_rate_Slick0150a" effect="bold">

A 
	program with a relatively constant frame rate - Slick0150a

</emphasis>


</title>




<para id="p1032">
I will begin by discussing a case with a relatively constant frame rate. The 
program for this case, 

<emphasis id="strong1024" effect="bold">
Slick0150a

</emphasis>
, is shown in 


<link id="a1041" target-id="Listing_9">

Listing 9

</link>

.

</para>




<section id="h31002">
<title>
<emphasis id="The_screen_output_for_Slick0150a" effect="bold">

The screen output for Slick0150a

</emphasis>


</title>




<para id="p1033">
Before getting into the coding details, I will show you some output.


<link id="a1042" target-id="Figure_3">

Figure 3

</link>

 shows a screen shot of the 
game window while the program is running.

</para>






<table id="table1002" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1002">
<row id="tr1004">
<entry id="th1002">



<emphasis id="Figure_3" effect="bold">

Figure 3

</emphasis>

. Screen shot of the program named Slick0150a.


</entry>
</row>
</thead>


<tbody id="tbody1002">
<row id="tr1005">
<entry id="td1002">



<media id="media1002" alt="Missing image" display="block">
<image id="img1002" mime-type="image/jpeg" src="../../media/slick0150a3.jpg" width="418" height="348"/>
</media>


</entry>
</row>
</tbody>


</tgroup>
</table>






<para id="p1034">
The screen shot in 

<link id="a1043" target-id="Figure_3">

Figure 3

</link>

 caught the ladybug in mid flight. As 
mentioned earlier, the next time it collides with one of the edges of the game 
window, it will bounce off and move in the opposite direction like a pool ball 
striking the cushion on the edge of a pool table.

</para>




<para id="p1035">
<emphasis id="strong1025" effect="bold">
The FPS output

</emphasis>
</para>




<para id="p1036">
As you learned in an earlier module, the text in the upper-left corner is the 
frame rate in frames per second computed and automatically displayed by the game 
engine. You will see later that a target frame rate of 60 frames per second was requested by 
calling the method named


<emphasis id="strong1026" effect="bold">
setTargetFrameRate

</emphasis>
 and passing 60 as a parameter. 

</para>




<para id="p1037">
At 60 frames per second, a time interval of 16.6666 milliseconds would be required to 
complete each frame. It appears that the


<emphasis id="strong1027" effect="bold">
setTargetFrameRate

</emphasis>
  
method truncates this value to an integer value of 16 milliseconds, which represents a frame 
rate of 62.5 frames per second. It also appears that the code that displays the frame rate 
converts the actual frame rate to an integer for display. Hence you see an FPS 
value of 62 in 

<link id="a1044" target-id="Figure_3">

Figure 3

</link>

.

</para>




<para id="p1038">
<emphasis id="strong1028" effect="bold">
The traversalTime output

</emphasis>
</para>




<para id="p1039">
The 

<emphasis id="strong1029" effect="bold">
traversalTime

</emphasis>
 output that you see in 

<link id="a1045" target-id="Figure_3">


Figure 3

</link>

 is computed and displayed by the program that we will examine 
shortly. This is the time required for the sprite to complete one round trip 
from the right edge to the left edge and back to the right edge.

</para>




<para id="p1040">
If you compile and run this program, you will see that the 

<emphasis id="strong1030" effect="bold">

traversalTime

</emphasis>
 value is reasonably stable at around 3015 milliseconds.

</para>


	

<para id="p1041">
<emphasis id="strong1031" effect="bold">
The theoretical traversalTime

</emphasis>
</para>




<para id="p1042">
Although it isn't shown here, a separate output on the command-line window 
reported the width of the background image to be 414 pixels and the width of the 
sprite to be 48 pixels. The sprite is never allowed to go outside the boundaries 
of the game window, so the one-way distance from the left edge to the right edge 
is 366 pixels. 

<emphasis id="em1002" effect="italics">
(This is the distance that the upper-left corner of the 
sprite travels during the one-way trip.)

</emphasis>
 The round-trip distance is twice 
that, or 732 pixels.

</para>




<para id="p1043">
You will see later that the sprite is caused to move horizontally by four 
pixels during each frame. At 62 frames per second, this represents a horizontal 
speed for the sprite of 248 pixels per second. At that speed, the sprite should 
complete the round trip in 2952 milliseconds. That is close enough to the 
typical reported time of 3015 milliseconds to validate the theoretical 
considerations.

</para>




<para id="p1044">
<emphasis id="strong1032" effect="bold">
Relatively smooth motion

</emphasis>
</para>




<para id="p1045">
When I compile and run this program, I see the sprite moving with a 
relatively smooth motion. Unless your computer is very slow, you should probably 
see the same thing.

</para>




</section>
<section id="h31003">
<title>
<emphasis id="Beginning_of_the_class_named_Slick0150a" effect="bold">

Beginning of the class named Slick0150a

</emphasis>


</title>




<para id="p1046">
<link id="a1046" target-id="Listing_1">

Listing 1

</link>

 shows the beginning of the class 
definition for the class named 

<emphasis id="strong1033" effect="bold">
Slick0150a

</emphasis>
.

</para>




	

<table id="table1003" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1003">

			

<row id="tr1006">

				

<entry id="th1003">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. Beginning of the class named Slick0150a.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1003">

			

<row id="tr1007">

				

<entry id="td1003">



<code id="pre1000" display="block">
public class Slick0150a extends BasicGame{
  
  Image bug = null;
  Image background = null;
  
  float backgroundWidth;
  float backgroundHeight;
  
  float bugX = 100;
  float bugY = 100;
  float bugWidth;
  float bugHeight;
  
  float bugXDirection = 1.0f;//initial direction to right
  float bugYDirection = 1.0f;//initial direction is down
  
  float xStep = 4.0f;//horizontal step size
  float yStep = 3.0f;//vertical step size
  
  float bugScale = 0.75f;//drawing scale factor
  
  //Used to compute and display the time required for the
  // bug to make each round trip across the game window
  // and back.
  long oldTime = 0;
  long traversalTime = 0;
  
  //Frame rate we would like to see and maximum frame
  // rate we will allow.
  int targetFPS = 60;
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1047">
<link id="a1047" target-id="Listing_1">

Listing 1

</link>

 consists entirely of instance variable 
	declarations. The purpose of each of these variables should become clear as 
	they are used later in the code. No explanation beyond the embedded comments 
	should be needed at this point.

</para>




</section>
<section id="h31004">
<title>
<emphasis id="The_constructor_and_the_main_method" effect="bold">

The constructor and the main 
method

</emphasis>


</title>




<para id="p1048">
There is nothing new in the constructor and the 

<emphasis id="strong1034" effect="bold">
main

</emphasis>
 method. 
You can view them both in 

<link id="a1048" target-id="Listing_9">

Listing 9

</link>

.

</para>




</section>
<section id="h31005">
<title>
<emphasis id="The_init_method" effect="bold">

The init method

</emphasis>


</title>




<para id="p1049">
The 

<emphasis id="strong1035" effect="bold">
init

</emphasis>
 method is shown in 

<link id="a1049" target-id="Listing_2">

Listing 2

</link>

. 
I will explain the new material in this method.

</para>




	

<table id="table1004" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1004">

			

<row id="tr1008">

				

<entry id="th1004">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. The init method for 
				Slick0150a.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1004">

			

<row id="tr1009">

				

<entry id="td1004">



<code id="pre1001" display="block">  public void init(GameContainer gc)
                                   throws SlickException {
    oldTime = gc.getTime();

    bug = new Image("ladybug.png");
    background = new Image("background.jpg");
    
    backgroundWidth = background.getWidth();
    backgroundHeight = background.getHeight();
    
    bugWidth = bug.getWidth()*bugScale;
    bugHeight = bug.getHeight()*bugScale;
    
    System.out.println(
                   "backgroundWidth: " + backgroundWidth);
    System.out.println(
                 "backgroundHeight: " + backgroundHeight);
    System.out.println("bugWidth: " + bugWidth);
    System.out.println("bugHeight: " + bugHeight);
    
    gc.setTargetFrameRate(targetFPS);//set frame rate
  }//end init
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1050">
<emphasis id="strong1036" effect="bold">
Get the time

</emphasis>
</para>




<para id="p1051">
The 

<emphasis id="strong1037" effect="bold">
GameContainer

</emphasis>
 class provides a method named 

<emphasis id="strong1038" effect="bold">
getTime

</emphasis>
, 
which is described simply as:

</para>




<para id="p1052">
<emphasis id="em1003" effect="italics">
"Get the accurate system time."

</emphasis>
</para>




<para id="p1053">
I am interpreting this to mean that the method will return the system time 
good to one millisecond relative to a well-defined time origin. 

</para>




<para id="p1054">
<emphasis id="em1004" effect="italics">
(Standard Java uses January 1, 1970 as the origin or epoch of time but 
Slick2D may use a different origin. Since we will be working with changes in 
time and not absolute time, the time origin doesn't matter.)

</emphasis>
</para>




<para id="p1055">
The 

<emphasis id="strong1039" effect="bold">
init

</emphasis>
 method in 

<link id="a1050" target-id="Listing_2">

Listing 2

</link>

 calls 
the 

<emphasis id="strong1040" effect="bold">
getTime

</emphasis>
 method to 
get and save the time in an instance variable named 

<emphasis id="strong1041" effect="bold">
oldTime

</emphasis>
. 
The values in this variable will be used later to compute the round-trip time 
required for the sprite to move across the game window and back to the starting 
point at the right edge of the window.

</para>




<para id="p1056">
<emphasis id="strong1042" effect="bold">
Create the images

</emphasis>
</para>




<para id="p1057">
<link id="a1051" target-id="Listing_2">

Listing 2

</link>

 creates the ladybug 

<emphasis id="strong1043" effect="bold">
Image

</emphasis>
 
object and the background 

<emphasis id="strong1044" effect="bold">
Image

</emphasis>
 object using code that you have 
seen before, and stores those object's references in the instance variables 
named 

<emphasis id="strong1045" effect="bold">
bug

</emphasis>
 and 

<emphasis id="strong1046" effect="bold">
background

</emphasis>
.

</para>




<para id="p1058">
<emphasis id="strong1047" effect="bold">
Get, save, and display the widths and heights of the images

</emphasis>
</para>




<para id="p1059">
Then 

<link id="a1052" target-id="Listing_2">

Listing 2

</link>

 calls accessor methods to get, save, 
and display the widths and the heights of the 

<emphasis id="strong1048" effect="bold">
bug

</emphasis>
 and 

<emphasis id="strong1049" effect="bold">

background

</emphasis>
 objects.

</para>




<para id="p1060">
<emphasis id="strong1050" effect="bold">
Set the target frame rate

</emphasis>
</para>




<para id="p1061">
Finally, 

<link id="a1053" target-id="Listing_2">

Listing 2

</link>

 calls the 

<emphasis id="strong1051" effect="bold">
setTargetFrameRate

</emphasis>
 method to set the target frame rate to 60 frames per 
second.

</para>




</section>
<section id="h31006">
<title>
<emphasis id="The_update_method" effect="bold">

The update method

</emphasis>


</title>




<para id="p1062">
The overridden 

<emphasis id="strong1052" effect="bold">
update

</emphasis>
 method begins in 

<link id="a1054" target-id="Listing_3">


Listing 3

</link>

.

</para>




<para id="p1063">
The code in 

<link id="a1055" target-id="Listing_3">

Listing 3

</link>

 uses a very simple approach to 
cause the sprite to exhibit motion.

</para>




	

<table id="table1005" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1005">

			

<row id="tr1010">

				

<entry id="th1005">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. Beginning of the update method for Slick0150a. 

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1005">

			

<row id="tr1011">

				

<entry id="td1005">



<code id="pre1002" display="block">  public void update(GameContainer gc, int delta)
                                    throws SlickException{
    //Compute new location for the sprite.
    bugX += bugXDirection*xStep;
    bugY += bugYDirection*yStep;
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1064">
    

<emphasis id="strong1053" effect="bold">
Compute new sprite locations

</emphasis>
</para>




<para id="p1065">
    Each time the 

<emphasis id="strong1054" effect="bold">
update

</emphasis>
 method is called, 

<link id="a1056" target-id="Listing_3">

Listing 3

</link>

 
computes new location coordinate values for the sprite, which are either 
increased or decreased by the values stored in 

<emphasis id="strong1055" effect="bold">
xStep

</emphasis>
 and


<emphasis id="strong1056" effect="bold">
yStep

</emphasis>
. 

</para>




<para id="p1066">
    Repetitive displays of the sprite in the new locations by the 

<emphasis id="strong1057" effect="bold">
render

</emphasis>
 
method produces the impression that the sprite is moving.

</para>




<para id="p1067">
    

<emphasis id="strong1058" effect="bold">
Step values are independent of the frame rate

</emphasis>
</para>




<para id="p1068">
    The step values are multiplied by the contents of direction variables in 

<link id="a1057" target-id="Listing_3">

Listing 3

</link>

, 
each of which contains either +1 or -1, and the products are added to the 
current location coordinates.

</para>




<para id="p1069">
    As you will see shortly, the algebraic signs of the direction variables 
are changed each time the sprite collides with an edge of the game window.

</para>




<para id="p1070">
    This code assumes a constant frame rate
    and does not correct for variations in the frame rate.
    In other words, the size of the step taken during each frame is the same 
regardless of how long it takes to complete a frame. If the computer is running 
below the target frame rate, the sprite will appear to move more slowly than 
would be the case if the computer is running at the target frame rate.

</para>




<para id="p1071">
<emphasis id="strong1059" effect="bold">
Collision detection

</emphasis>
</para>




<para id="p1072">
The code in 

<link id="a1058" target-id="Listing_4">

Listing 4

</link>

 begins by detecting a 
collision of the right edge of the sprite with the right edge of the game window and 
reverses the sprite's direction of motion when a collision occurs.

</para>




<para id="p1073">
Note that if the rightmost portion of the sprite actually tries to move 
beyond the right edge of the game window, it is stopped at the edge of the game 
window.

</para>




	

<table id="table1006" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1006">

			

<row id="tr1012">

				

<entry id="th1006">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Detection of collision 
				with right edge.


</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1006">

			

<row id="tr1013">

				

<entry id="td1006">



<code id="pre1003" display="block">
    if(bugX+bugWidth &gt;= backgroundWidth){
      //A collision has occurred.
      bugXDirection = -1.0f;//reverse direction
      //Set the position to the right edge less the width
      // of the sprite.
      bugX = backgroundWidth - bugWidth;
      
      //Compute traversal time for the bug to make one
      // round trip across the game window and back.
      long currentTime = gc.getTime();
      traversalTime = currentTime - oldTime;
      oldTime = currentTime;
    }//end if
    
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1074">
<emphasis id="strong1060" effect="bold">
Compute and save the traversal time

</emphasis>
</para>




<para id="p1075">
Then the code in 

<link id="a1059" target-id="Listing_4">

Listing 4

</link>

 computes the elapsed time 
since the previous collision of the sprite with the right edge of the game 
window and saves that time interval in the variable named 

<emphasis id="strong1061" effect="bold">
traversalTime

</emphasis>
. 
That 

<emphasis id="strong1062" effect="bold">
traversalTime

</emphasis>
 value will be displayed when the 

<emphasis id="strong1063" effect="bold">

render

</emphasis>
 method is called producing the output shown in


<link id="a1060" target-id="Figure_3">

Figure 3

</link>

.

</para>




<para id="p1076">
<emphasis id="strong1064" effect="bold">
Test for collisions on other three sides of game window

</emphasis>
</para>




<para id="p1077">
<link id="a1061" target-id="Listing_5">

Listing 5

</link>

 tests for collisions between the sprite 
and the other three sides of the game window and takes appropriate action when a 
collision occurs. The code in these tests is less complex than in


<link id="a1062" target-id="Listing_4">

Listing 4

</link>

 because they don't need to compute the


<emphasis id="strong1065" effect="bold">
traversalTime

</emphasis>
.

</para>




	

<table id="table1007" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1007">

			

<row id="tr1014">

				

<entry id="th1007">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. Test for collisions on 
				other three sides of game window.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1007">

			

<row id="tr1015">

				

<entry id="td1007">



<code id="pre1004" display="block">
    //Continue testing for collisions with the edges.
    if(bugX &lt;= 0){
      bugXDirection = 1.0f;
      bugX = 0;
    }//end if
    
    if(bugY+bugHeight &gt;= backgroundHeight){
      bugYDirection = -1.0f;
      bugY = backgroundHeight - bugHeight;
    }//end if
    
    if(bugY &lt;= 0){
      bugYDirection = 1.0f;
      bugY = 0;
    }//end if
    
  }//end update
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

</section>
<section id="h31007">
<title>
<emphasis id="The_render_method" effect="bold">

The render method

</emphasis>


</title>


	


<para id="p1078">
The render method is shown in its entirety in 

<link id="a1063" target-id="The_render_method">


Listing 6

</link>

.

</para>




	

<table id="table1008" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1008">

			

<row id="tr1016">

				

<entry id="th1008">
<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. The render method for Slick150a.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1008">

			

<row id="tr1017">

				

<entry id="td1008">



<code id="pre1005" display="block">  public void render(GameContainer gc, Graphics g)
                                    throws SlickException{
    //set the drawing mode to honor transparent pixels
    g.setDrawMode(g.MODE_NORMAL);
    
    //Draw the background to erase the previous picture.
    background.draw(0,0);
    
    //Draw the bug in its new location.
    bug.draw(bugX,bugY,bugScale);
    
    //Display the traversal time computed in the update
    // method.
    g.drawString(
                "traversalTime: "+traversalTime,100f,10f);

  }//end render
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1079">
There is really nothing new in 

<link id="a1064" target-id="The_render_method">

Listing 6

</link>

. 
	Therefore, it shouldn't require an explanation beyond the embedded comments.

</para>




<para id="p1080">
Each time this method is called, the location of the sprite will have changed 
by a few pixels relative to its previous location. Displaying the sprite in a 
new location each time the picture is drawn produces the impression that the 
sprite is moving.

</para>




</section>
</section>
<section id="h21002">
<title>
<emphasis id="A_program_with_a_highly_variable_frame_rate_Slick0150b" effect="bold">

A program with a highly 
variable frame rate - Slick0150b

</emphasis>


</title>


	

<para id="p1081">
    This program differs from the previous program in that it attempts to maintain a constant overall speed as the bug moves across the game window despite the fact that the 
	instantaneous frame rate varies quite a bit from one frame to the next. To 
	accomplish this, the step size is made to vary in proportion to 
	the delta 
	value received by the 

<emphasis id="strong1066" effect="bold">
update

</emphasis>
 method, or inversely with the 
	instantaneous frame rate.

</para>




<para id="p1082">
A complete listing of the program is provided in 

<link id="a1065" target-id="Listing_10">


Listing 10

</link>

 near the end of 
the module. Most of the code in this program is the same as code in the previous 
program, so I will explain only the code that differs between the two.

</para>




<section id="h31008">
<title>
<emphasis id="The_screen_output_for_Slick0150b" effect="bold">

The screen output for Slick0150b

</emphasis>


</title>




<para id="p1083">
<link id="a1066" target-id="Figure_4">

Figure 4

</link>

 shows a screen shot of the game window while this program is 
running. I will have more to say about this output later after I explain some of 
differences between this program and the program named 

<emphasis id="strong1067" effect="bold">
Slick0150a

</emphasis>
.

</para>






<table id="table1009" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1009">
<row id="tr1018">
<entry id="th1009">



<emphasis id="Figure_4" effect="bold">

Figure 4

</emphasis>

. Screen shot of the program named Slick0150b. 

</entry>
</row>
</thead>


<tbody id="tbody1009">
<row id="tr1019">
<entry id="td1009">



<media id="media1003" alt="Missing image." display="block">
<image id="img1003" mime-type="image/jpeg" src="../../media/slick0150b1.jpg" width="421" height="333"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>






</section>
<section id="h31009">
<title>
<emphasis id="The_render_method_2" effect="bold">

The render method

</emphasis>


</title>




<para id="p1084">
The significant differences between the two programs occur in the 

<emphasis id="strong1068" effect="bold">

update

</emphasis>
 method and the 

<emphasis id="strong1069" effect="bold">
render

</emphasis>
 method. I will 
begin with an explanation of the 

<emphasis id="strong1070" effect="bold">
render

</emphasis>
 method, which purposely 
creates an issue that is resolved by code in the 

<emphasis id="strong1071" effect="bold">
update

</emphasis>
 method.

</para>


	

<para id="p1085">
The 

<emphasis id="strong1072" effect="bold">
render

</emphasis>
 method is shown in its entirety in 

<link id="a1067" target-id="Listing_7">


	Listing 7

</link>

.

</para>




	

<table id="table1010" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1010">

			

<row id="tr1020">

				

<entry id="th1010">
<emphasis id="Listing_7" effect="bold">

Listing 7

</emphasis>

. The render method for 
				Slick150b.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1010">

			

<row id="tr1021">

				

<entry id="td1010">

				

<code id="pre1006" display="block">  public void render(GameContainer gc, Graphics g)
                                    throws SlickException{
    //set the drawing mode to honor transparent pixels
    g.setDrawMode(g.MODE_NORMAL);//honors transparency

    //Draw the background to erase the previous picture.
    background.draw(0,0);

    //Draw the bug in its new location.
    bug.draw(bugX,bugY,bugScale);

    //Display the traversal time computed in the update
    // method.
    g.drawString(
                "traversalTime: "+traversalTime,100f,10f);

    //Purposely insert a time delay.
    int sleepTime = (((byte)random.nextInt()) + 128)/6;
    gc.sleep(sleepTime);

  }//end render</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1086">
<emphasis id="strong1073" effect="bold">
Purposely insert a time delay

</emphasis>
</para>




<para id="p1087">
Everything down to the last two lines of code in 

<link id="a1068" target-id="Listing_7">


	Listing 7

</link>

 is the same as the program named 

<emphasis id="strong1074" effect="bold">
Slick0150a

</emphasis>
. 
At that point I inserted code that will cause an additional random time 
delay ranging from 0 to 43 milliseconds before the 

<emphasis id="strong1075" effect="bold">
render

</emphasis>
 
method returns. I did this to simulate a 
situation in which the rendering process is very complex and the time to render 
varies quite a lot from one frame to the next. 

</para>




<para id="p1088">
<emphasis id="strong1076" effect="bold">
A new average frame rate

</emphasis>
</para>




<para id="p1089">
In this case, the average additional delay time should be about 21.5 msec. 
This makes it impossible to maintain the target frame rate of 60 
frames per second or 16.666 milliseconds per frame.

</para>




<para id="p1090">
This additional delay should result in an average frame rate of about 46 or 
47 frames per second, which is consistent with the screen output shown in


<link id="a1069" target-id="Figure_4">

Figure 4

</link>

.

</para>




<para id="p1091">
<emphasis id="strong1077" effect="bold">
A wide variation in delta values

</emphasis>
</para>




<para id="p1092">
Not only does this code result in a reduction in the average frame rate, it 
also results in a wide variation in the values of delta received by the 

<emphasis id="strong1078" effect="bold">
update

</emphasis>
 
method on a frame to frame basis.

</para>




<para id="p1093">
As before, the 

<emphasis id="strong1079" effect="bold">
init

</emphasis>
 method calls the 

<emphasis id="strong1080" effect="bold">
setTargetFrameRate

</emphasis>
 method requesting a frame rate of 60 
frames per second. This guarantees that the minimum delta that will be received 
by the 

<emphasis id="strong1081" effect="bold">
update

</emphasis>
 method will be in the neighborhood of 16 
milliseconds. 

<emphasis id="em1005" effect="italics">
(The game loop won't be allowed to run any faster than 60 
frames per second.)

</emphasis>
</para>




<para id="p1094">
The last two lines of code in 

<link id="a1070" target-id="Listing_7">

Listing 7

</link>

 will cause 
the value of delta to be as large as about 43 milliseconds. 

</para>




<para id="p1095">
Therefore, the 
incoming delta values in the 

<emphasis id="strong1082" effect="bold">
update

</emphasis>
 method will vary between 
about 16 milliseconds and about 43 milliseconds on a totally random basis from 
one frame to the next.

</para>


	

</section>
<section id="h31010">
<title>
<emphasis id="The_update_method_2" effect="bold">

The update method

</emphasis>


</title>




<para id="p1096">
<link id="a1071" target-id="Listing_8">

Listing 8

</link>

 shows the code in the 

<emphasis id="strong1083" effect="bold">
update

</emphasis>
 method that 
is different from the code in the 

<emphasis id="strong1084" effect="bold">
update

</emphasis>
 method for the program named 

<emphasis id="strong1085" effect="bold">

Slick0150b

</emphasis>
.

</para>




	

<table id="table1011" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1011">

			

<row id="tr1022">

				

<entry id="th1011">
<emphasis id="Listing_8" effect="bold">

Listing 8

</emphasis>

. Beginning of the update method for Slick0150b.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1011">

			

<row id="tr1023">

				

<entry id="td1011">

				

<code id="pre1007" display="block">  public void update(GameContainer gc, int delta)
                                    throws SlickException{
    //Compute new location for the sprite.
    bugX += bugXDirection*xStep*delta*targetFPS/1000.0;
    bugY += bugYDirection*yStep*delta*targetFPS/1000.0;

    //The following code does not correct for variations
    // in delta. The step size is always the same
    // regardless of delta. Enable this code and disable
    // the two statements above to see the effect.
//    bugX += bugXDirection*xStep;
//    bugY += bugYDirection*yStep;
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>




	

<para id="p1097">
    

<emphasis id="strong1086" effect="bold">
Compute new location for the sprite

</emphasis>
</para>




<para id="p1098">
    As before, the method begins by computing a new location for the sprite. 
However, the code in 

<link id="a1072" target-id="Listing_8">

Listing 8

</link>

 attempts to maintain a constant
    overall speed as the bug moves across the game
    window despite the fact that the value of delta varies quite a bit from one frame to the next. 

</para>




<para id="p1099">
    

<emphasis id="strong1087" effect="bold">
Vary the step size

</emphasis>
</para>




<para id="p1100">
    In order to accomplish this, the step
    size is caused to vary in proportion to delta or inversely
    with the instantaneous frame rate. Given the earlier estimate that the value of delta can 
vary from about 16 milliseconds to about 43 milliseconds, the step size can vary 
from about 4 pixels per frame to about 10 pixels per frame. When the value of 
delta is small, the step size will be small. When the value of delta is large, 
the step size will be large.

</para>




<para id="p1101">
    

<emphasis id="strong1088" effect="bold">
Maintaining a constant overall speed of motion

</emphasis>
</para>




<para id="p1102">
    As a result of the long time delays introduced into the 

<emphasis id="strong1089" effect="bold">
render

</emphasis>
 
method, the average frame rate has been slowed down to around 47 frames per second as 
shown in 

<link id="a1073" target-id="Figure_4">

Figure 4

</link>

. However, as also shown in 

<link id="a1074" target-id="Figure_4">


Figure 4

</link>

, the traversal time continues to be close to the target of around 
3000 milliseconds. Therefore, the algorithm is deemed to be successful in 
maintaining a relatively constant overall speed of motion.

</para>




<para id="p1103">
    

<emphasis id="strong1090" effect="bold">
The visible output

</emphasis>
</para>




<para id="p1104">
    This algorithm and the widely varying values of delta result in sprite 
motion that isn't as smooth as with the program named 

<emphasis id="strong1091" effect="bold">
Slick0150b

</emphasis>
. However, the 
sprite gets to where it needs to be when it needs to be there despite widely 
varying values of delta, and that is the objective of the algorithm.

</para>




<para id="p1105">
    

<emphasis id="strong1092" effect="bold">
Results without correction for varying frame rate

</emphasis>
</para>




<para id="p1106">
    The last two statements in 

<link id="a1075" target-id="Listing_8">

Listing 8

</link>

 show an 
alternative approach that does not attempt to correct for variations in the 
value of delta. 

</para>




<para id="p1107">
    

<emphasis id="em1006" effect="italics">
(This approach is essentially the same as was used in the program 
named 

<emphasis id="strong1093" effect="bold">
Slick0150a

</emphasis>
 above.)

</emphasis>
</para>




<para id="p1108">
    When the first two statements in 

<link id="a1076" target-id="Listing_8">

Listing 8

</link>

 
are disabled and the last two statements in 

<link id="a1077" target-id="Listing_8">

Listing 8

</link>

 
are enabled, the output is as shown in 

<link id="a1078" target-id="Figure_5">

Figure 5

</link>

.

</para>






<table id="table1012" summary="This is a table." pgwide="1">
<tgroup cols="1">


<thead id="thead1012">
<row id="tr1024">
<entry id="th1012">



<emphasis id="Figure_5" effect="bold">

Figure 5

</emphasis>

. Screen shot of the program named Slick0150b without correction for 
varying frame rate.

</entry>
</row>
</thead>


<tbody id="tbody1012">
<row id="tr1025">
<entry id="td1012">



<media id="media1004" alt="Missing image." display="block">
<image id="img1004" mime-type="image/jpeg" src="../../media/slick0150b2.jpg" width="418" height="346"/>
</media>




</entry>
</row>
</tbody>


</tgroup>
</table>






<para id="p1109">
<emphasis id="strong1094" effect="bold">
Increased traversal time

</emphasis>
</para>




<para id="p1110">
<link id="a1079" target-id="Figure_5">

Figure 5

</link>

 shows the output of a system where the value 
of delta varies widely but no correction is made for those variations. As you 
can see, the frame rate is reduced as in 

<link id="a1080" target-id="Figure_4">

Figure 4

</link>

. As 
you can also see, the traversal time is increased significantly from around 3000 
milliseconds to around 4300 milliseconds. As a result, the sprite does 

<emphasis id="strong1095" effect="bold">



<emphasis id="em1007" effect="italics">
not

</emphasis>
</emphasis>
 get 
to where it needs to be when it needs to be there.

</para>






</section>
</section>
</section>
<section id="h11005">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the programs

</emphasis>


</title>






<para id="p1111">
I encourage you to copy the code from 

<link id="a1081" target-id="Listing_9">

Listing 9

</link>

 and 


<link id="a1082" target-id="Listing_10">

Listing 10

</link>

. Compile the code and execute 
it, 
making changes, and observing the results of your changes. Make certain that you 
can explain why your changes behave as they do.

</para>


	

</section>
<section id="h11006">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1112">
In this module, you learned how to make sprites move at a constant speed in 
front of an image in the face of a widely varying frame rate. You also learned 
about a rudimentary form of collision detection.

</para>




</section>
<section id="h11007">
<title>
<emphasis id="Whats_next" effect="bold">

What's next?

</emphasis>


</title>




<para id="p1113">
In the next module, you will learn about using the 

<emphasis id="strong1096" effect="bold">
draw

</emphasis>
, 

<emphasis id="strong1097" effect="bold">

drawCentered

</emphasis>
, and 

<emphasis id="strong1098" effect="bold">
drawFlash

</emphasis>
 methods of the


<link id="a1083" url="http://slick.ninjacave.com/javadoc/org/newdawn/slick/Image.html">


Image

</link>

 class.

</para>


	

</section>
<section id="h11008">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1114">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1000" type="">


		


			


				

<emphasis id="strong1099" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1008" list-type="bulleted">

					

<item id="li1038">
Module name: Slick0150: A first look at sprite motion, collision detection, and timing control

</item>


					

<item id="li1039">
File: Slick0150.htm


</item>


					

<item id="li1040">
Published: 02/04/13

</item>


					

<item id="li1041">
Revised: 06/09/15 for 64-bit

</item>


				

</list>


				

</note>

			


		



	






	

<note id="note1001" type="">


		


			


				

<emphasis id="strong1100" effect="bold">
Disclaimers:

</emphasis>
<para id="p1115">
<emphasis id="strong1101" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>


				

<para id="p1116">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>


				

<para id="p1117">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>


				

<para id="p1118">
<emphasis id="strong1102" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>


				

</note>

			


		



	





</section>
<section id="h11009">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listings

</emphasis>


</title>




<para id="p1119">
<link id="a1084" target-id="Listing_9">

Listing 9

</link>

 and 

<link id="a1085" target-id="Listing_10">

Listing 10

</link>

 provide complete listings of the programs discussed 
in this module.

</para>





	

<table id="table1013" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1013">

			

<row id="tr1026">

				

<entry id="th1013">
<emphasis id="Listing_9" effect="bold">

Listing 9

</emphasis>

. Source code for the 
				program named Slick0150a.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1013">

			

<row id="tr1027">

				

<entry id="td1013">



<code id="pre1008" display="block">
/*Slick0150a.java
Copyright 2012, R.G.Baldwin

Cause a ladybug sprite to bounce around inside the game
window.

Tested using JDK 1.7 under WinXP
*********************************************************/

import org.newdawn.slick.AppGameContainer;
import org.newdawn.slick.BasicGame;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

public class Slick0150a extends BasicGame{
  
  Image bug = null;
  Image background = null;
  
  float backgroundWidth;
  float backgroundHeight;
  
  float bugX = 100;
  float bugY = 100;
  float bugWidth;
  float bugHeight;
  
  float bugXDirection = 1.0f;//initial direction to right
  float bugYDirection = 1.0f;//initial direction is down
  
  float xStep = 4.0f;//horizontal step size
  float yStep = 3.0f;//vertical step size
  
  float bugScale = 0.75f;//drawing scale factor
  
  //Used to compute and display the time required for the
  // bug to make each round trip across the game window
  // and back.
  long oldTime = 0;
  long traversalTime = 0;
  
  //Frame rate we would like to see and maximum frame
  // rate we will allow.
  int targetFPS = 60;
  //----------------------------------------------------//

  public Slick0150a(){//constructor
    //Set the title
    super("Slick0150a, baldwin");
  }//end constructor
  //----------------------------------------------------//

  public static void main(String[] args)
                                    throws SlickException{
    AppGameContainer app = new AppGameContainer(
                          new Slick0150a(),414,307,false);
    app.start();
  }//end main
  //----------------------------------------------------//

  @Override
  public void init(GameContainer gc)
                                   throws SlickException {
    oldTime = gc.getTime();

    bug = new Image("ladybug.png");
    background = new Image("background.jpg");
    
    backgroundWidth = background.getWidth();
    backgroundHeight = background.getHeight();
    
    bugWidth = bug.getWidth()*bugScale;
    bugHeight = bug.getHeight()*bugScale;
    
    System.out.println(
                   "backgroundWidth: " + backgroundWidth);
    System.out.println(
                 "backgroundHeight: " + backgroundHeight);
    System.out.println("bugWidth: " + bugWidth);
    System.out.println("bugHeight: " + bugHeight);
    
    gc.setTargetFrameRate(targetFPS);//set frame rate
  }//end init
  //----------------------------------------------------//

  @Override
  public void update(GameContainer gc, int delta)
                                    throws SlickException{
    //Compute new location for the sprite.
    
    //The following code assumes a constant frame rate
    // and does not correct for variations in delta.
    // The step size is always the same regardless of
    // delta (how often the steps are taken).
    bugX += bugXDirection*xStep;
    bugY += bugYDirection*yStep;
    
    //Test for collisions with the sides of the game
    // window and reverse direction when a collision
    // occurs.
    if(bugX+bugWidth &gt;= backgroundWidth){
      //A collision has occurred.
      bugXDirection = -1.0f;//reverse direction
      //Set the position to the right edge less the width
      // of the sprite.
      bugX = backgroundWidth - bugWidth;
      
      //Compute traversal time for the bug to make one
      // round trip across the game window and back.
      long currentTime = gc.getTime();
      traversalTime = currentTime - oldTime;
      oldTime = currentTime;
    }//end if
    
    //Continue testing for collisions with the edges.
    if(bugX &lt;= 0){
      bugXDirection = 1.0f;
      bugX = 0;
    }//end if
    
    if(bugY+bugHeight &gt;= backgroundHeight){
      bugYDirection = -1.0f;
      bugY = backgroundHeight - bugHeight;
    }//end if
    
    if(bugY &lt;= 0){
      bugYDirection = 1.0f;
      bugY = 0;
    }//end if
    
  }//end update
  //----------------------------------------------------//

  public void render(GameContainer gc, Graphics g)
                                    throws SlickException{
    //set the drawing mode to honor transparent pixels
    g.setDrawMode(g.MODE_NORMAL);
    
    //Draw the background to erase the previous picture.
    background.draw(0,0);
    
    //Draw the bug in its new location.
    bug.draw(bugX,bugY,bugScale);
    
    //Display the traversal time computed in the update
    // method.
    g.drawString(
                "traversalTime: "+traversalTime,100f,10f);

  }//end render

}//end class Slick0150a
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1120">
.

</para>




	

<table id="table1014" summary="This is a table." pgwide="677">
<tgroup cols="1">


		

<thead id="thead1014">

			

<row id="tr1028">

				

<entry id="th1014">
<emphasis id="Listing_10" effect="bold">

Listing 10

</emphasis>

. Source code for the program named Slick0150b.

</entry>

			

</row>

		

</thead>


		

<tbody id="tbody1014">

			

<row id="tr1029">

				

<entry id="td1014">



<code id="pre1009" display="block">
/*Slick0150b.java
Copyright 2012, R.G.Baldwin

Cause a ladybug sprite to bounce around inside the game
window.

A random time delay is inserted in the render method to
simulate a situation where the rendering process is very
complex and the time to render varies from one frame to
the next.

The program attempts to maintain a constant physical
speed as the bug moves across the game window despite
the fact that the delta varies quite a bit from one
frame to the next. The step size varies in proportion
to delta or inversely with frame rate.

Tested using JDK 1.7 under WinXP
*********************************************************/

import org.newdawn.slick.AppGameContainer;
import org.newdawn.slick.BasicGame;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;
import java.util.Random;

public class Slick0150b extends BasicGame{
  Random random = new Random();

  Image bug = null;
  Image background = null;

  float backgroundWidth;
  float backgroundHeight;

  float bugX = 100;//initial position of ladybug
  float bugY = 100;
  float bugWidth;
  float bugHeight;

  float bugXDirection = 1.0f;//initial direction to right
  float bugYDirection = 1.0f;//initial direction is down

  float xStep = 4.0f;//horizontal step size
  float yStep = 3.0f;//vertical step size

  float bugScale = 0.75f;//drawing scale factor

  //Used to compute and display the time required for the
  // bug to make each round trip across the game window
  // and back.
  long oldTime = 0;
  long traversalTime = 0;

  //Frame rate we will simulate in terms of the speed of
  // the sprite and maximum frame rate we will allow.
  // We will use this value to achieve a constant overall
  // speed of motion for the sprite regardless of the
  // actual frame rate.
  int targetFPS = 60;
  //----------------------------------------------------//

  public Slick0150b(){//constructor
    //Set the title
    super("Slick0150b, baldwin");
  }//end constructor
  //----------------------------------------------------//

  public static void main(String[] args)
                                    throws SlickException{
    AppGameContainer app = new AppGameContainer(
                          new Slick0150b(),414,307,false);
    app.start();
  }//end main
  //----------------------------------------------------//

  @Override
  public void init(GameContainer gc)
                                   throws SlickException {
    oldTime = gc.getTime();

    bug = new Image("ladybug.png");
    background = new Image("background.jpg");

    backgroundWidth = background.getWidth();
    backgroundHeight = background.getHeight();

    bugWidth = bug.getWidth()*bugScale;
    bugHeight = bug.getHeight()*bugScale;

    System.out.println(
                   "backgroundWidth: " + backgroundWidth);
    System.out.println(
                 "backgroundHeight: " + backgroundHeight);
    System.out.println("bugWidth: " + bugWidth);
    System.out.println("bugHeight: " + bugHeight);

    gc.setTargetFrameRate(targetFPS);//set frame rate
  }//end init
  //----------------------------------------------------//

  @Override
  public void update(GameContainer gc, int delta)
                                    throws SlickException{
    //Compute new location for the sprite.

    //The following code attempts to maintain a constant
    // overall speed as the bug moves across the game
    // window despite the fact that the delta varies
    // quite a bit from one frame to the next. The step
    // size varies in proportion to delta or inversely
    // with the frame rate.
    bugX += bugXDirection*xStep*delta*targetFPS/1000.0;
    bugY += bugYDirection*yStep*delta*targetFPS/1000.0;

    //The following code does not correct for variations
    // in delta. The step size is always the same
    // regardless of delta. Enable this code and disable
    // the two statements above to see the effect.
//    bugX += bugXDirection*xStep;
//    bugY += bugYDirection*yStep;

    //Test for collisions with the sides of the game
    // window and reverse direction when a collision
    // occurs.
    if(bugX+bugWidth &gt;= backgroundWidth){
      //A collision has occurred.
      bugXDirection = -1.0f;//reverse direction
      //Set the position to the right edge less the width
      // of the sprite.
      bugX = backgroundWidth - bugWidth;

      //Compute traversal time for the bug to make one
      // round trip across the game window and back.
      long currentTime = gc.getTime();
      traversalTime = currentTime - oldTime;
      oldTime = currentTime;
    }//end if

    //Continue testing for collisions with the edges.
    if(bugX &lt;= 0){
      bugXDirection = 1.0f;
      bugX = 0;
    }//end if

    if(bugY+bugHeight &gt;= backgroundHeight){
      bugYDirection = -1.0f;
      bugY = backgroundHeight - bugHeight;
    }//end if

    if(bugY &lt;= 0){
      bugYDirection = 1.0f;
      bugY = 0;
    }//end if

  }//end update
  //----------------------------------------------------//

  public void render(GameContainer gc, Graphics g)
                                    throws SlickException{
    //set the drawing mode to honor transparent pixels
    g.setDrawMode(g.MODE_NORMAL);//honors transparency

    //Draw the background to erase the previous picture.
    background.draw(0,0);

    //Draw the bug in its new location.
    bug.draw(bugX,bugY,bugScale);

    //Display the traversal time computed in the update
    // method.
    g.drawString(
                "traversalTime: "+traversalTime,100f,10f);

    //Insert an additional random time delay ranging from
    // 0 to 43 msec to simulate a situation where the
    // rendering process is very complex and the time
    // to render varies quite a lot from one frame to
    // the next. The average delay time should be about
    // 21.5 msec, which should result in an average FPS of
    // about 46 or 47 FPS reduced by the additional time
    // that would be required to complete a frame in the
    // absence of this time delay.
    int sleepTime = (((byte)random.nextInt()) + 128)/6;
    gc.sleep(sleepTime);

  }//end render

}//end class Slick0150b
</code>



				

</entry>

			

</row>

		

</tbody>


	

</tgroup>
</table>






<para id="p1121">
-end- 

</para>






</section>
</content>




</document>